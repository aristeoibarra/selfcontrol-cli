#!/bin/bash

# SelfControl CLI - Main Executable
# Production-ready command-line interface for SelfControl.app
# Version: 3.0.0

set -euo pipefail

# =============================================================================
# INITIALIZATION
# =============================================================================

# Determine script location
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check if we're in development mode (lib directory exists relative to script)
if [[ -d "$ROOT_DIR/lib" && -f "$ROOT_DIR/lib/core.sh" ]]; then
    readonly LIB_DIR="$ROOT_DIR/lib"
else
    # Production mode - libraries are in ~/.local/lib/selfcontrol-cli
    readonly LIB_DIR="$HOME/.local/lib/selfcontrol-cli"
fi

# Source libraries
# shellcheck source=lib/core.sh
source "$LIB_DIR/core.sh"
# shellcheck source=lib/schedule.sh
source "$LIB_DIR/schedule.sh"

# Source LaunchAgent management (if available)
if [[ -f "$ROOT_DIR/scripts/launchagent.sh" ]]; then
    # shellcheck source=scripts/launchagent.sh
    source "$ROOT_DIR/scripts/launchagent.sh"
elif [[ -f "$HOME/.local/lib/selfcontrol-cli/launchagent.sh" ]]; then
    # shellcheck source=scripts/launchagent.sh
    source "$HOME/.local/lib/selfcontrol-cli/launchagent.sh"
fi

# =============================================================================
# COLOR CONSTANTS
# =============================================================================

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# =============================================================================
# COMMAND FUNCTIONS
# =============================================================================

# Show help information
cmd_help() {
    cat << 'EOF'
SelfControl CLI - Automated Scheduled Blocking for macOS

USAGE:
    selfcontrol-cli <command> [options]

COMMANDS:
üìä Status & Information:
    status              Show current SelfControl and schedule status
    info                Show detailed block information
    version             Show version and system information

üöÄ Block Management:
    start [minutes]       Start manual block (default: 120 minutes)

‚è∞ Schedule Management:
    schedule list       Show all configured schedules
    schedule status     Show current schedule status
    schedule enable <name>      Enable specific schedule
    schedule disable <name>     Disable specific schedule
    schedule reload     Reload configuration from file
    schedule test       Test schedule logic in real-time

üõ†Ô∏è Service Management (LaunchAgent):
    service status      Show LaunchAgent service status
    service start       Start (load) LaunchAgent service
    service stop        Stop (unload) LaunchAgent service
    service restart     Restart LaunchAgent service
    service logs [n]    Show LaunchAgent logs (default: 20 lines)
ü§ñ Service Management (v3.0.0):
    service status      Show LaunchAgent service status
    service start       Start LaunchAgent service
    service stop        Stop LaunchAgent service
    service restart     Restart LaunchAgent service
    service logs        Show LaunchAgent logs

üîß Utility:
    init                Initialize configuration and directories

EXAMPLES:
    selfcontrol-cli start 240           # Block for 4 hours (240 minutes)
    selfcontrol-cli schedule list       # Show all schedules
    selfcontrol-cli schedule enable work_hours
    selfcontrol-cli schedule test       # Test schedule logic
    selfcontrol-cli service status      # Check LaunchAgent status
For more information, visit:
https://github.com/aristeoibarra/selfcontrol-cli
EOF
}

# Show version information
cmd_version() {
    echo "SelfControl CLI v$SELFCONTROL_CLI_VERSION"
    echo "Production-ready scheduled blocking for macOS"
    echo ""
    echo "SelfControl.app integration: $([ -x "$SELFCONTROL_CLI_PATH" ] && echo "‚úÖ Available" || echo "‚ùå Not found")"
    echo "Configuration: $([ -f "$SCHEDULE_CONFIG" ] && echo "‚úÖ Found" || echo "‚ùå Not found")"
    echo ""
    echo "Paths:"
    echo "  Root directory: $ROOT_DIR"
    echo "  Config file: $SCHEDULE_CONFIG"
    echo "  Log file: $SCHEDULE_LOG"
}

# Initialize SelfControl CLI
cmd_init() {
    echo "üöÄ Initializing SelfControl CLI..."
    echo ""

    # Create default configuration if it doesn't exist
    if [[ ! -f "$SCHEDULE_CONFIG" ]]; then
        local example_config="$ROOT_DIR/config/schedule.example.json"
        if [[ -f "$example_config" ]]; then
            cp "$example_config" "$SCHEDULE_CONFIG"
            echo "‚úÖ Created default configuration from example"
        else
            # Create minimal configuration
            cat > "$SCHEDULE_CONFIG" << 'JSON'
{
  "global_settings": {
    "check_interval": 5,
    "timezone": "auto",
    "prevent_duplicates": true,
    "log_level": "info"
  },
  "schedules": [],
  "blocklists": {
    "default": "blocklist.selfcontrol"
  },
  "logging": {
    "enabled": true,
    "max_size_mb": 10,
    "keep_days": 30
  }
}
JSON
            echo "‚úÖ Created minimal default configuration"
        fi
    fi

    # Create default blocklist if it doesn't exist
    local default_blocklist="$ROOT_DIR/config/blocklist.selfcontrol"
    if [[ ! -f "$default_blocklist" ]]; then
        local example_blocklist="$ROOT_DIR/config/blocklist.example.selfcontrol"
        if [[ -f "$example_blocklist" ]]; then
            cp "$example_blocklist" "$default_blocklist"
            echo "‚úÖ Created default blocklist from example"
        else
            echo "‚ö†Ô∏è  No default blocklist found. Please create: $default_blocklist"
        fi
    fi

    echo ""
    echo "üéâ SelfControl CLI initialized successfully!"
    echo ""
    echo "Next steps:"
    echo "1. Customize your schedule: $SCHEDULE_CONFIG"
    echo "2. Customize your blocklist: $default_blocklist"
    echo "3. Ensure LaunchAgent is running: selfcontrol-cli service status"
    echo "4. Test with 'selfcontrol-cli schedule test'"
}

# Live status monitoring with real-time updates
show_live_status() {
    local refresh_interval="$1"

    echo "üî¥ Live Status Monitor (Ctrl+C to exit)"
    echo "‚è∞ Refresh interval: ${refresh_interval}s"
    echo "========================================"

    # Handle Ctrl+C gracefully
    trap 'echo -e "\nüëã Live monitoring stopped"; exit 0' INT

    while true; do
        # Clear screen and show current time
        clear
        echo "üî¥ SelfControl CLI - Live Status Monitor"
        echo "========================================"
        echo "üìÖ $(date '+%Y-%m-%d %H:%M:%S (%A)')"
        echo "‚è∞ Refresh: ${refresh_interval}s | Press Ctrl+C to exit"
        echo ""

        # Show main status
        show_single_status

        echo ""
        echo "üìä LaunchAgent Activity:"
        echo "------------------------"

        # Show recent schedule log entries
        if [[ -f "$SCHEDULE_LOG" ]]; then
            echo "üìã Recent Activity (last 5 entries):"
            tail -5 "$SCHEDULE_LOG" | while IFS= read -r line; do
                echo "   $line"
            done
        else
            echo "   No schedule log found"
        fi

        echo ""
        echo "üîÑ Next update in ${refresh_interval}s..."

        # Wait for refresh interval
        sleep "$refresh_interval"
    done
}

# Display single status check (used by both normal and live modes)
show_single_status() {
    local live_mode=false
    local refresh_interval=5

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --live|-l)
                live_mode=true
                shift
                ;;
            --interval|-i)
                refresh_interval="$2"
                shift 2
                ;;
            *)
                echo "‚ùå Unknown option: $1"
                echo "Usage: selfcontrol-cli status [--live] [--interval N]"
                echo "  --live, -l        Enable live monitoring mode"
                echo "  --interval, -i N  Set refresh interval in seconds (default: 5)"
                return 1
                ;;
        esac
    done

    if ! init_selfcontrol_cli; then
        die "Failed to initialize SelfControl CLI"
    fi

    if [[ "$live_mode" == "true" ]]; then
        show_live_status "$refresh_interval"
        return
    fi

    if is_selfcontrol_running; then
            echo "üîí SelfControl: ACTIVE"

            # Get detailed info if available
            local settings
            if settings=$(get_selfcontrol_settings); then
                local end_date_utc
                end_date_utc=$(echo "$settings" | grep "BlockEndDate" | sed 's/.*"\([^"]*\)".*/\1/')

                if [[ -n "$end_date_utc" ]]; then
                    local end_timestamp now_timestamp
                    end_timestamp=$(date -j -f "%Y-%m-%d %H:%M:%S %z" "$end_date_utc" "+%s" 2>/dev/null)
                    now_timestamp=$(date "+%s")
                    local remaining_seconds=$((end_timestamp - now_timestamp))

                    if [[ $remaining_seconds -gt 0 ]]; then
                        local remaining_hours=$((remaining_seconds / 3600))
                        local remaining_minutes=$(((remaining_seconds % 3600) / 60))
                        echo "‚è∞ Remaining: ${remaining_hours}h ${remaining_minutes}m"
                    fi
                fi
            fi

            # Check if this was started by a schedule
            if [[ -f "$SCHEDULE_CONFIG" ]]; then
                local active_schedule
                if active_schedule=$(get_active_schedule 2>/dev/null); then
                    local schedule_name
                    schedule_name=$(json_get_value "$active_schedule" "name" "unknown")
                    echo "üìÖ Active schedule: $schedule_name"
                fi
            fi
    else
        echo "‚úÖ SelfControl: INACTIVE"
            # Check if there's an active schedule that should be running
            if [[ -f "$SCHEDULE_CONFIG" ]]; then
                local active_schedule
                if active_schedule=$(get_active_schedule 2>/dev/null); then
                    local schedule_name end_time remaining
                    schedule_name=$(json_get_value "$active_schedule" "name" "unknown")
                    end_time=$(json_get_value "$active_schedule" "end_time" "")
                    remaining=$(get_remaining_minutes "$end_time")
                    echo "‚ö†Ô∏è  Schedule '$schedule_name' should be active!"
                    echo "‚è∞ Should run until: $end_time ($((remaining / 60))h $((remaining % 60))m left)"
                    echo "üí° LaunchAgent will automatically start scheduled blocks"
                else
                    echo "üí° Ready to start a new block"
                fi
            else
                echo "üí° Ready to start a new block"
            fi
    fi
}

# Detailed information
cmd_info() {
    if ! init_selfcontrol_cli; then
        die "Failed to initialize SelfControl CLI"
    fi

    echo "üìä SelfControl CLI Information"
    echo "=============================="
    echo ""

    # Version info
    echo "Version: $SELFCONTROL_CLI_VERSION"
    echo "SelfControl.app: $([ -x "$SELFCONTROL_CLI_PATH" ] && echo "‚úÖ Available" || echo "‚ùå Not found")"
    echo ""

    # Current status
    echo "Current Status:"
    cmd_status
    echo ""

    # Configuration info
    if [[ -f "$SCHEDULE_CONFIG" ]]; then
        echo "Configuration: ‚úÖ Found"
        local schedule_count
        schedule_count=$(grep -c '"name"' "$SCHEDULE_CONFIG" 2>/dev/null || echo "0")
        echo "Schedules configured: $schedule_count"
    else
        echo "Configuration: ‚ùå Not found"
        echo "Run 'selfcontrol-cli init' to create default configuration"
    fi
    echo ""

    # Log info
    if [[ -f "$SCHEDULE_LOG" ]]; then
        echo "Log file: ‚úÖ Found ($(wc -l < "$SCHEDULE_LOG") lines)"
    else
        echo "Log file: ‚ùå Not found"
    fi
}

# Start manual block
cmd_start() {
    local minutes="${1:-120}"
    local blocklist_file="$HOME/.config/selfcontrol-cli/blocklist.selfcontrol"

    if ! init_selfcontrol_cli; then
        die "Failed to initialize SelfControl CLI"
    fi

    # Check if already running
    if is_selfcontrol_running; then
        echo "‚ö†Ô∏è  SelfControl is already running"
        echo "Use 'selfcontrol-cli status' to see remaining time"
        exit 1
    fi

    # Validate minutes
    if ! echo "$minutes" | grep -qE '^[0-9]+(\.[0-9]+)?$'; then
        die "Invalid minutes format: $minutes"
    fi

    # Check if blocklist exists
    if [[ ! -f "$blocklist_file" ]]; then
        die "Blocklist file not found. Run 'selfcontrol-cli init' to create default configuration."
    fi

    # Calculate end date
    local minutes_to_add=$minutes
    # minutes_to_add is already in minutes
    local end_date
    end_date=$(date -v +${minutes_to_add}M '+%Y-%m-%d %H:%M:%S')

    echo "üöÄ Starting SelfControl block..."
    # Display duration in a clear format
    if [[ $minutes -lt 60 ]]; then
        echo "Duration: $minutes minutes"
    elif [[ $minutes -eq 60 ]]; then
        echo "Duration: 1 hour"
    else
        local hours_display
        hours_display=$(echo "scale=1; $minutes / 60" | bc)
        echo "Duration: $hours_display hours"
    fi
    echo "Ends at: $end_date"
    echo ""

    # Start block
    start_selfcontrol_block "$minutes" "$blocklist_file"

    echo "‚úÖ Block started successfully!"
    echo "Use 'selfcontrol-cli status' to check remaining time"
}

# Schedule management commands
cmd_schedule() {
    local subcommand="${1:-list}"
    shift || true

    case "$subcommand" in
        "list")
            echo "üìÖ SelfControl Scheduled Blocks"
            echo ""
            echo "üïê Current time: $(date '+%A, %B %d - %H:%M')"
            echo ""

            if [[ ! -f "$SCHEDULE_CONFIG" ]]; then
                echo "‚ùå No configuration found. Run 'selfcontrol-cli init' first."
                return 1
            fi

            local config
            if ! config=$(load_schedule_config); then
                echo "‚ùå Failed to load configuration"
                return 1
            fi

            # Extract schedules array using python for better JSON parsing
            local schedules
            schedules=$(echo "$config" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    schedules = data.get('schedules', [])
    for schedule in schedules:
        print(json.dumps(schedule))
except:
    pass
")

            if [[ -z "$schedules" ]]; then
                echo "No schedules configured."
                return 0
            fi

            # Display each schedule
            echo "$schedules" | while read -r schedule; do
                local name enabled start_time end_time days description
                name=$(json_get_value "$schedule" "name")
                enabled=$(json_get_value "$schedule" "enabled" "false")
                start_time=$(json_get_value "$schedule" "start_time")
                end_time=$(json_get_value "$schedule" "end_time")
                days=$(json_get_array "$schedule" "days")
                description=$(json_get_value "$schedule" "description" "")

                echo "üìã $name"
                if [[ -n "$description" ]]; then
                    echo "   Description: $description"
                fi
                echo "   Status: $([ "$enabled" == "true" ] && echo "‚úÖ Enabled" || echo "‚ùå Disabled")"
                echo "   Time: $start_time - $end_time"
                echo "   Days: $(echo "$days" | tr '\n' ' ')"
                echo ""
            done
            ;;
        "status")
            echo "üìä Schedule Status"
            echo "=================="
            echo ""

            local active_schedule
            if active_schedule=$(get_active_schedule 2>/dev/null); then
                local schedule_name
                schedule_name=$(json_get_value "$active_schedule" "name" "unknown")
                echo "üéØ Active schedule: $schedule_name"
            else
                echo "üéØ No active schedule"
            fi
            ;;
        "enable")
            local schedule_name="$1"
            if [[ -z "$schedule_name" ]]; then
                echo "‚ùå Please specify a schedule name"
                echo "Usage: selfcontrol-cli schedule enable <name>"
                return 1
            fi

            if update_schedule_status "$schedule_name" "true"; then
                echo "‚úÖ Enabled schedule: $schedule_name"
            else
                echo "‚ùå Failed to enable schedule: $schedule_name"
                return 1
            fi
            ;;
        "disable")
            local schedule_name="$1"
            if [[ -z "$schedule_name" ]]; then
                echo "‚ùå Please specify a schedule name"
                echo "Usage: selfcontrol-cli schedule disable <name>"
                return 1
            fi

            if update_schedule_status "$schedule_name" "false"; then
                echo "‚úÖ Disabled schedule: $schedule_name"
            else
                echo "‚ùå Failed to disable schedule: $schedule_name"
                return 1
            fi
            ;;
        "reload")
            echo "üîÑ Reloading configuration..."
            if load_schedule_config >/dev/null; then
                echo "‚úÖ Configuration reloaded successfully"
            else
                echo "‚ùå Failed to reload configuration"
                return 1
            fi
            ;;
        "test")
            test_schedule_logic
            ;;
        *)
            echo "‚ùå Unknown schedule command: $subcommand"
            echo "Available commands: list, status, enable, disable, reload, test"
            return 1
            ;;
    esac
}

# Service management commands (LaunchAgent)
cmd_service() {
    local subcommand="${1:-status}"
    shift || true

    # Check if LaunchAgent functions are available
    if ! command -v launchagent_main >/dev/null 2>&1; then
        echo "‚ùå LaunchAgent management not available"
        echo "Please update your installation or check that launchagent.sh is properly installed."
        return 1
    fi

    launchagent_main "$subcommand" "$@"
}

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        "help"|"-h"|"--help")
            cmd_help
            ;;
        "version"|"-v"|"--version")
            cmd_version
            ;;
        "init")
            cmd_init
            ;;
        "status"|"st")
            cmd_status
            ;;
        "info")
            cmd_info
            ;;
        "start")
            cmd_start "$1"
            ;;
        "schedule"|"sched")
            cmd_schedule "$@"
            ;;
        "service"|"svc")
            cmd_service "$@"
            ;;
        "_launchagent_check")
            # Internal command called by LaunchAgent - not documented for users
            check_and_execute_schedules
            ;;
        *)
            echo "‚ùå Unknown command: $command"
            echo ""
            echo "Use 'selfcontrol-cli help' for usage information."
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
